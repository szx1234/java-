java中的protected是用于同包中的继承，另一个包中的子类只能继承父类的public ，protected方法或成员变量以及方法,继承的类可以访问这些变量，但是如果是protected类型，则不能对外界展示，必须重写，或者int a ＝ c；
super();this();必须写在第一行
如果一个类定义了有参数的构造器，则jvm不会给类提供默认构造器，如果子类继承了没有默认构造器的类，子类必须在构造器中用super(参数)；
调用父类的构造器，并且super（参数）；必须写在构造器中的第一行；

this是一个引用，所以静态方法中不可能有这个；（静态方法属于类这个模板的）

静态方法的重写没有多态

重写的规则：
	1：方法的参数，方法的返回类型，方法的名字不可以改变
	2：方法的权限不能缩小
	3：方法不能抛出新的异常，所有异常都得在方法内部try catch掉
注意：在子类中重写父类的方法或者成员变量，实际上是把继承过来的方法和变量隐藏了，可以通过super来调用

java 初始化过程
一进main函数，就会加载最超类的静态成员，以及静态块，依次往子类进行初始化
如果main函数生成了某类的对象，则必须也是从最超类开始，先初始化成员变量和显示初始化块（两者无先后顺序，按序执行），
再执行构造函数，之后子类依次类推

注意：父类构造方法中，被调用的一般方法是执行重写后的行为，但其依赖的子类成员变量此时还没有显示初始化，
这样就会导致错误的行为（这个是多态造成的，运行时识别）

java类的加载的时刻：
	1：在首次实例化这个类时（使用该类的构造方法）
	2：在首次调用类的静态方法或者静态变量时加载此类（main函数是静态方法）
	3：在子类需要加载时，需要先加载父类
注意：构造方法不是静态方法，因为它可以调用非静态的方法

java加载类时会进行初始化类的静态变量的显示初始化，以及执行静态初始化块：
初始化过程：
	1：先初始化父类的的静态变量，以及静态初始化块（按代码顺序执行，两者没有先后顺序）
	2：初始化子类的静态变量，以及静态初始化块（按代码顺序执行，两者没有先后顺序）


类的实例化过程：
	1：如果没有加载先加载；

	2：先执行父类的显示初始化，和显示初始化块（按代码顺序执行，两者没有先后顺序）
	3：执行父类的构造函数

	4：执行子类的显示初始化，和显示初始化块（按代码顺序执行，两者没有先后顺序）（同2）
	5：执行子类的构造函数（同3）



final关键字
	1：使用在类中表示该类不可以被继承；
	2：使用在方法之前表示该方法不能被重写（可以继承）
	3：在参数中使用表示此变量不能被修改（普通类型的值不能被修改，  应用类型的引用不能被修改， 而其对应的堆中的非final变量可以被修改）
注意：如果final成员变量没有显示初始化，则必须在构造函数中经行初始化


抽象类：
1：抽象类即可以有抽象方法也可以没有
2：抽象类不能实例化但是有构造方法，子类的的构造方法可以调用父类的构造方法（父类构造方法是用来初始化变量的）
3：抽象类可以继承自普通类也可以继承自抽象类
4: 抽象类和普通类的区别是不能初始化，和可以有抽象方法，所以抽象类可以有所有普通类所拥有的成员
4：模版设计模式用到了抽象类


接口：接口只可以定义常量和抽象方法
	可以是void f();  和   int i = 0;
	但是系统会自动把它改成public abstract void f();  和   public final static int i = 0;

普通类中的final变量必须在它所有的构造函数中声明，不能只在一个构造函数中声明

内部类：成员内部类，局部内部类，匿名内部类

java多线程：
java中有两种方法实现多线程
1：通过写一个新类来继承Thread方法，并重写run()方法，run（）方法是线程的执行代码块，当继承Thread类的实例对象调用start（）方法时，java虚拟机会自动去生成一个新的额线程并执行此类的run()方法

Thread可以有名字getName();可以获取名字，在Thread构造方法中可以穿入一个String字符串作为此线程名字


2：通过实现runnable接口，接口中只有一个run()方法，此接口不是线程，要想执行此线程，就要new Thread(new A()).start;   ::::A类实现了Runnable接口，并重写了该方法


symchronize（Object obj）{}是同步代码块，此代码块在执行时只能有一个线程执行此代码

symchronize也可以作为修饰符，放到函数声明里，此函数就是同步函数了
例子
public symchronize void f(){}


同步函数使用的锁是this

静态同步函数的锁是Class对象

单例设计模式：内存中只存在一个此类的实例，单例设计模式分为两种，第一种饿汉式，第二种懒汉式，两者区别是后者延迟加载，等需要时才生成此对象
1：饿汉式
class Single{
	private static final Single s = new Single();
	private Single(){};
	public static Single getSingleInstance(){
		return s;
	}
}

//非多线程下的懒汉单例模式
class Single{
	private static Single s = null;
	private Single(){};
	public static Single getSingleInstance(){
		if(s == null)
			s = new Single();
		return s;
	}
}
//多线程下的懒汉单例模式
class Single{
	private static Single s = null;
	private Single(){};
	public static Single getSingleInstance(){
		if(s == null)
			synchornized{
				if(s == null)
					s = new Single();
			}
		return s;
	}
}




监听器与回调函数：
监听器是用来监听事件的，控件或组件可以设置监听器（setOnClickListener(   new OnClickListener(View v){回调函数});   ）监听器可以监听控件发出的事件并做出响应（响应就是调用回调函数）； 监听器的参数是控件产生事件并发送给监听器的事件的相关信息！



java范型，范型可以是类也可以是集合，范型参数必须是引用类型
范型方法中的范型参数T放在修饰符与返回类型之间
接口也可以定义范型，类实现接口范型有两种方法
  1:class A extends Ainterface<String>，确定了类型
  2:class A extends Ainterface<T>, 没确定类型
